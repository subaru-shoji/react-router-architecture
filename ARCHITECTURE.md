## プロジェクトの設計図：ソフトウェアアーキテクチャ入門

ようこそ！このドキュメントは、私たちのプロジェクトがどのような「設計図」（ソフトウェアアーキテクチャ）に基づいて作られているかを、特に開発を始めたばかりの方にも分かりやすく説明するためのものです。

### なぜ「設計図」が必要なの？

家を建てるとき、いきなりレンガを積み始める人はいませんよね？まず、どんな部屋があって、どこにキッチンがあって、どこにドアをつけるか、といった「設計図」を描きます。

ソフトウェア開発も同じです。しっかりとした設計図があれば、

* **整理整頓しやすい:** コードがどこに何があるか分かりやすくなります。
* **協力しやすい:** チームの他のメンバーが何をしているか理解しやすくなります。
* **変更・追加しやすい:** 新しい機能を追加したり、既存の機能を修正したりするのが楽になります。
* **間違いが起きにくい:** コードが整理されていると、バグ（不具合）が入り込みにくくなります。

このプロジェクトでは、「クリーンアーキテクチャ」と「ドメイン駆動設計 (DDD)」、そして「CQRS」という考え方を取り入れた設計図を採用しています。難しく聞こえるかもしれませんが、一つずつ見ていきましょう。

### 全体の考え方：役割分担がしっかりした会社みたい！

このプロジェクトの構造は、役割分担がしっかり決まっている会社や、整理されたキッチンのようなものだと考えてください。

* **クリーンアーキテクチャ:** 一番大事な「会社の中心業務」や「キッチンのレシピ」は、他のどうでもいいこと（例えば、どのメーカーの電話を使うか、どのブランドのオーブンを使うか）の影響を受けないように、大切に守ります。依存関係は常に「外側」から「内側」へ向かいます。
* **ドメイン駆動設計 (DDD):** 「会社の中心業務」や「料理のレシピ」そのものにしっかり焦点を当てて、ソフトウェアを作ります。ビジネスで使われている言葉をコードの中でも使うようにします。
* **CQRS:** 「情報を問い合わせる仕事」と「情報を変更する仕事」を、別の担当者が行うように役割分担します。

### プロジェクトの「部署」紹介 (ディレクトリ構造)

プロジェクトの `app` ディレクトリの中は、いくつかの「部署」に分かれています。それぞれの部署が特定の仕事を担当しています。

---

#### 1. `app/domain` (ビジネス専門家チーム)

* **役割:** このプロジェクトが扱う「ビジネスそのもの」のルールや知識が詰まっている、一番大事な中心部です。アプリケーションの「心臓」と言えます。
* **例え:** 会社の「経営戦略部」や、キッチンの「秘伝のレシピブック」。
* **中身:**
    * `model`: ビジネスに出てくる重要なモノや概念 (例: `User` (ユーザー), `Order` (注文) )。レシピの材料リストのようなものです。
    * `repository` (インターフェース): データの保存や読み込みの「やり方（契約）」だけを決めます (例: 「ユーザーを探す機能」「注文を保存する機能」)。実際にどうやって保存するか(例: どのデータベースを使うか)は、ここでは決めません。「注文用紙」のようなものです。
        * `i_***_query_repository.ts`: データを**探す・読み込む**ための契約書。
        * `i_***_command_repository.ts`: データを**新しく作る・変更する・消す**ための契約書。
    * `gateway` (インターフェース): 他の重要なシステム（サブシステムなど）と連携するための「やり方（契約）」を決めます。「外部業者への専用連絡窓口の仕様書」のようなものです。
    * `service`: 複数のモノや概念が関わる、少し複雑なビジネスルール (例: 「注文時の送料計算」)。複数の材料を使う複雑なレシピのようなものです。
    * `facade`: メインのビジネスとサブシステムが関わるような、特に複雑な連携作業を調整する専門家。「複数のレシピや外部から取り寄せた食材を組み合わせて、コース料理全体を管理するシェフ長」のようなイメージです。
* **ポイント:** この部署は、データベースの種類やウェブページの見た目など、**技術的な詳細や外部のことは一切気にしません**。純粋なビジネスルールだけに集中します。コードは基本的に普通のTypeScriptで書かれます。

---

#### 2. `app/application` (業務進行マネージャーチーム)

* **役割:** 「ビジネス専門家チーム (`domain`)」の知識を使って、具体的なアプリケーションの機能（ユースケース）を実行するチームです。
* **例え:** 会社の「プロジェクトマネージャー」や、キッチンの「フロアマネージャー」。
* **中身:**
    * `use_case`: アプリケーションができる具体的な「仕事」の１つ１つ (例: 「ユーザーを新しく登録する」「注文の詳細を表示する」)。マネージャーが専門家チームに指示を出す流れ、のようなものです。彼らは `domain` が決めた「契約書 (`repository`, `gateway`, `facade` のインターフェース)」を使って仕事を依頼します。
    * `dto` (Data Transfer Object): 部署間でデータを運ぶための、シンプルな「データ運搬用ケース」。中身がごちゃ混ぜにならないように、決まった形でデータをやり取りします。
* **ポイント:** 外の世界（ウェブのリクエストなど）と、内部のビジネスルール (`domain`) を繋ぐ橋渡し役です。

---

#### 3. `app/infrastructure` (設備・道具管理チーム)

* **役割:** 「どうやってやるか」という技術的な詳細を担当します。データベースとの実際のやり取り、外部APIとの通信など、具体的な道具や設備を管理します。
* **例え:** 会社の「IT部門」や「物流部門」、キッチンの「倉庫」や「配達トラック」、「特定のメーカーのオーブン」。
* **中身:**
    * `db`: データベースの設定や接続情報 (このプロジェクトでは Drizzle ORM を使います)。
    * `repository` (実装): `domain` が決めた「契約書 (`repository` インターフェース)」に従って、**実際に** Drizzle ORM を使ってデータベースにデータを保存したり読み込んだりするコード。「注文用紙 (`Query/Command Repository I/F`)」を見て、倉庫 (`db`) から実際に品物を持ってきたり、棚にしまったりする「倉庫係」です。
        * `drizzle_***_query_repository.ts`: データを**読み込む**具体的な処理。
        * `drizzle_***_command_repository.ts`: データを**変更する**具体的な処理。
    * `gateway` (実装): `domain` が決めた「契約書 (`gateway` インターフェース)」に従って、**実際に**外部のサブシステムと通信するコード。「仕様書」を見て、外部業者に**実際に**電話をかけたり、データを送ったりする「渉外担当」です。
    * `service`: メール送信機能など、その他の技術的な便利ツール。
* **ポイント:** アプリケーションが動くために必要な、具体的な技術や外部との接続部分が全てここに集まっています。

---

#### 4. `app/interface` (見た目担当チーム)

* **役割:** 主にユーザーが直接目にする部分（見た目）を担当します。
* **例え:** お店の「ショーウィンドウ」や「内装デザイン」。
* **中身:**
    * `component`: アプリケーション全体で再利用できる見た目の部品 (例: ボタン、入力フォーム、カード表示)。
* **ポイント:** ユーザーがどう操作するか、どう見えるか、に関わる部分です。

---

#### 5. `app/route` (受付・案内係チーム)

* **役割:** ウェブブラウザからのアクセス（リクエスト）を受け付け、適切な担当部署（主に `application` チーム）に処理を依頼し、最終的な結果（ウェブページ）をユーザーに返す、玄関口です。このプロジェクトでは ReactRouter フレームワークがこの役割の多くを担います。
* **例え:** 会社の「受付」や、レストランの「案内係」。
* **中身:**
    * 各ルートディレクトリ (例: `/home`, `/user/:id`): 特定のURLに対応するファイル置き場。
    * `route.tsx` ファイル:
        * `loader`: ページが表示される**前**にサーバーでデータを準備する機能。`application` チームにデータ取得を依頼します。
        * `action`: ユーザーがフォーム送信などを行った**後**にサーバーで処理を実行する機能。`application` チームにデータ更新などを依頼します。
        * `XxxxPage` コンポーネント: `loader` で準備されたデータを使って、実際にブラウザに表示されるページの見た目（HTML）を作る部分。`interface/component` の部品を使ったりします。
* **ポイント:** ユーザーからのインターネット経由での入口となり、リクエストに応じて適切な処理を呼び出し、結果を返します。

---

### データはどう流れるの？ (例：ユーザープロフィール表示)

1.  **ユーザー:** ブラウザで `/user/profile/123` にアクセス。
2.  **`app/route` (受付):** `/user/profile.$userId/route.tsx` がリクエストを受け取る。
3.  **`loader` (受付内の案内係):** ページ表示に必要なデータを準備するため、`application` チームの「ユーザー情報取得」担当 (`GetUserProfileUseCase`) を呼び出す。
4.  **`app/application/use_case` (業務マネージャー):** 「ユーザー情報取得」の仕事を開始。`domain` チームの「ユーザーデータ取得契約書 (`IUserQueryRepository`)」を使って、データ取得を依頼。
5.  **`app/infrastructure/repository` (倉庫係):** `IUserQueryRepository` の契約に基づき、`DrizzleUserQueryRepository` が Drizzle ORM を使ってデータベースから ID `123` のユーザーを探す。
6.  **データが戻る:** 倉庫係 (`infrastructure`) → マネージャー (`application`) → 受付 (`loader`) へ、見つかったユーザーデータが返される。
7.  **`XxxxPage` コンポーネント (受付内の表示係):** `loader` から受け取ったデータを使って、プロフィールページのHTMLを生成。
8.  **ユーザー:** ブラウザにプロフィールページが表示される。

### まとめ：この設計図の良いところ

* **整理されている:** コードがどこにあるべきか明確です。
* **テストしやすい:** 各部署（レイヤー）を個別にテストできます。特に `domain` は、他の技術詳細に依存しないためテストが簡単です。
* **変更に強い:** 例えば、データベースを Drizzle から別のものに変えたくなっても、変更は主に `infrastructure` チーム内で行えばよく、`domain` や `application` への影響は最小限です。
* **ビジネスに集中できる:** 一番大事な `domain` (ビジネスルール) が他の部分から守られているため、安心してビジネスロジックの開発に集中できます。

### 命名規則：コードの一貫性を保つために

プロジェクト内のファイルやコードの命名には、以下の規則を適用しています：

* **ファイル名の規則:**
  * **TSXファイル:** PascalCase（先頭大文字）を使用します。
    * 例: `UserProfile.tsx`, `OrderDetail.tsx`, `Button.tsx`
  * **その他のファイル:** snake_case（小文字とアンダースコア）を使用します。
    * 例: `user_repository.ts`, `order_service.ts`, `database_client.ts`

* **単数形の使用:** ファイル名やクラス名には複数形ではなく単数形を使います。
  * 例: `user.ts`（`users.ts`ではない）, `product.ts`（`products.ts`ではない）

* **その他の命名規則:**
  * クラス用のインターフェース名の先頭には `I` をつけます（例: `IUserRepository`）
  * クラス名はその役割を明確に示す名前にします（例: `DrizzleUserRepository`）
  * 変数名や関数名はその目的や動作を明確に表す名前にします

これらの命名規則に従うことで、コードの可読性が向上し、チーム内での一貫性が保たれます。また、ファイルの役割や内容が名前から直感的に理解しやすくなります。

### 初心者の方へ：歩き方のヒント

* **まずは `domain/model` を見てみよう:** このアプリケーションがどんな「モノ」を扱っているのか理解するのが第一歩です。
* **次に `application/use_case` を見てみよう:** このアプリケーションがどんな「機能」を提供しているのか掴みましょう。
* **機能を追加するときは？:**
    1.  その機能の中心的なビジネスルールは？ (`domain`)
    2.  アプリケーションとしての具体的な手順は？ (`application/useCase`)
    3.  データの保存や読み込み、外部連携はどうする？ (`infrastructure/repository`, `infrastructure/gateway`)
    4.  ユーザーはどう操作して、どう見える？ (`app/route`, `app/interface/component`)
    …という順番で考えると、どこにコードを書けばよいか分かりやすくなります。
* **既存のコードを真似てみよう:** 似たような機能がどう実装されているか見るのが一番の近道です。
* **分からなければ質問しよう！:** GeminiやChatgptに聞いてください。


---

```
/app
├── domain/                     # ドメイン層: コアビジネスロジックとルール
│   ├── model/                  #   - エンティティ、値オブジェクトなど
│   │   └── user.ts             #     例: User エンティティ定義
│   ├── repository/             #   - リポジトリインターフェース (Query/Command分離)。必ず分離する必要はない。その場合は、i_user_repository (Optional。serviceやfacade等で必要になったら用意するといい。)
│   │   ├── i_user_query_repository.ts     #     例: User データ取得用インターフェース
│   │   └── i_user_command_repository.ts   #     例: User データ更新用インターフェース
│   ├── gateway/                #   - 外部(サブシステム)アクセスインターフェース (Optional。serviceやfacade等で必要になったら用意するといい。)
│   │   └── i_sub_system_data_gateway.ts #     例: サブシステムデータ操作インターフェース
│   ├── service/                #   - ドメインサービス (複雑なビジネスロジック) (Optional)
│   │   └── point_calculation_service.ts #     例: ポイント計算ロジック
│   └── facade/                 #   - ドメインファサード (ドメイン内連携調整) (Optional)
│       └── user_management_facade.ts #     例: ユーザー関連の複雑な連携を扱う
│
├── application/              # アプリケーション層: ユースケース、アプリケーション固有ロジック
│   ├── use_case/                #   - ユースケース
│   │   └── get_user_use_case.ts     #     例: ユーザー取得ユースケース
│   │   └── create_user_use_case.ts  #     例: ユーザー作成ユースケース
│   └── dto/                    #   - データ転送オブジェクト (Optional。書く量が増えるので、あとで追加する方針でもいい)
│       └── user_dto.ts          #     例: ユーザー情報転送用オブジェクト
│
├── infrastructure/           # インフラストラクチャ層: 技術的詳細、外部連携実装
│   ├── db/                     #   - Drizzle ORM 関連
│   │   ├── schema.ts           #     - Drizzle スキーマ定義
│   │   ├── client.ts           #     - Drizzle Client インスタンス化
│   │   └── migrate.ts          #     - Drizzle マイグレーションスクリプト (Optional)
│   ├── repository/             #   - リポジトリ実装 (Drizzle使用) 必ず分離する必要はない。その場合は、IUser_repository
│   │   ├── drizzle_user_query_repository.ts    #     - User取得リポジトリ実装
│   │   └── drizzle_user_command_repository.ts  #     - User更新リポジトリ実装
│   ├── gateway/                #   - ゲートウェイ実装 (外部API等連携) (Optional)
│   │   └── sub_system_data_api_adapter.ts   #     - サブシステムAPIアダプター実装
│   └── service/                #   - インフラ固有サービス実装 (Optional)
│       └── send_grid_email_service.ts #     - 例: Email送信サービス実装
│
├── interface/                # インターフェースアダプター層: UI部品など
│   └── component/              #   - 再利用可能なUIコンポーネント
│       └── Button.tsx          #     例: 共通ボタンコンポーネント
│
├── route/                    # ルーティング層: ReactRouterのルーティング定義
│   └── user/                   #   - ユーザー関連ルート用ディレクトリ例
│       ├── UserListPage.tsx        #   - /usersを表示する (loader/action含む)
│       └── UserCard.tsx         #  - User情報表示用のコンポーネント
│
├── entry.client.tsx          # ReactRouter クライアントエントリーポイント
├── entry.server.tsx          # ReactRouter サーバーエントリーポイント (DIコンテナ, DBクライアント初期化等)
└── root.tsx                  # ReactRouter ルートレイアウトコンポーネント
│
/drizzle/                     # Drizzle 設定ファイル・生成物用ディレクトリ (Optional)
drizzle.config.ts             # Drizzle 設定ファイル
package.json                  # プロジェクト定義ファイル
tsconfig.json                 # TypeScript 設定ファイル
# ... 他の設定ファイル (例: .env, .gitignore)
```




### なぜ DDD・クリーンアーキテクチャ・CQRS を使うの？ ～もっと開発を楽にするための道具たち～

ソフトウェア開発をしていると、プロジェクトが大きくなるにつれて、こんな悩みが出てきませんか？

* 「このコード、何やってるんだっけ…？」 (コードが複雑で読みにくい)
* 「ここを直したら、あっちが壊れた！」 (変更の影響範囲が分かりにくい)
* 「新しい機能を追加するのが大変…」 (どこに手をつければいいか分からない)
* 「テスト書くのが面倒くさい…」 (一部分だけをテストするのが難しい)
* 「お客さんや先輩が言ってる『ビジネスのルール』って、コードのどこにあるの？」 (大事なロジックが色々な場所に散らばっている)

これらの悩みを解決して、もっと開発をスムーズに進めるために、先人たちが考え出した「やり方」や「考え方」があります。それが、今回私たちのプロジェクトで採用している **DDD (ドメイン駆動設計)**、**クリーンアーキテクチャ**、そして **CQRS** なんです。

それぞれがどんな問題を解決してくれるのか、見ていきましょう！

---

#### 1. DDD (ドメイン駆動設計): 「ビジネス」をちゃんと理解して、コードの中心に置こう！

* **どんな問題を解決するの？**
    * ソフトウェアが解決したい「ビジネス上の問題」や「ルール」（これを**ドメイン**と呼びます）が、コードから読み取りにくい。
    * 開発者とお客さん（やビジネス担当者）の間で言葉が食い違い、認識ズレが起きる。
* **考え方:**
    * ソフトウェア開発で一番大事なのは、そのソフトウェアが扱う「ビジネスの領域（ドメイン）」を深く理解すること。
    * そして、そのビジネスのルールや言葉を、そのままコードの中心的な設計に反映させる。
    * **例:** ECサイトなら、「商品 (Product)」「注文 (Order)」「顧客 (Customer)」といったビジネス用語が、そのままコードのクラス名や変数名 (`app/domain/model` の中身) になる。
* **開発者にとってのメリット:**
    * **コードが分かりやすくなる:** ビジネスで使われている言葉がコードに出てくるので、「このコードは何のための処理か」が直感的に理解しやすくなります。
    * **コミュニケーションがスムーズに:** 設計の話をするときに、ビジネス担当者と同じ言葉で話せるので、認識のズレが減ります。
    * **本質的な開発ができる:** 技術的な詳細だけでなく、「このソフトウェアは何を実現するのか」という本質的な部分に関われます。

---

#### 2. クリーンアーキテクチャ: コードを「整理整頓」して、大事なものを守ろう！

* **どんな問題を解決するの？**
    * データベースのコード、画面表示(UI)のコード、ビジネスルール…全部がごちゃ混ぜになって、スパゲッティみたいに絡まってしまう。
    * 一部分を変更しただけなのに、関係ないはずの場所でバグが出る。
    * 「データベースを新しいものに変えたい」と思っても、影響が大きすぎて手が出せない。
* **考え方:**
    * コードを役割ごとに「層（レイヤー）」に分けて、きれいに整理整頓する。
    * 一番大事な「ビジネスルール (`domain`)」は中心に置き、他の層（データベース、UI、Webフレームワークなど）の詳細を知らないように、大切に保護する。
    * 依存関係は必ず「外側」から「内側」へ。中心のビジネスルールは、外側の都合に振り回されない！
    * **例:** `app/domain` は `app/infrastructure` (データベースの実装など) のことを知らない。でも `infrastructure` は `domain` が決めたルール（インターフェース）に従う。
* **開発者にとってのメリット:**
    * **コードを書く場所に迷わない:** 「この処理はどのディレクトリに書くべきか」が明確になります (`domain`, `application`, `infrastructure`, `route` など)。
    * **変更が怖くなくなる:** UIの変更は `interface` や `route`、データベースの変更は `infrastructure` を主に触ればOK、というように、影響範囲が限定されるので、安心して修正できます。
    * **テストがしやすい:** 中心となるビジネスルール (`domain`, `application`) は、データベースやWebサーバーが無くても単体でテストできます。テストが速くて簡単になります。
    * **チーム開発がしやすい:** 「私はUI担当」「僕はデータベース担当」のように、役割分担して並行して作業しやすくなります。

---

#### 3. CQRS: 「データを見る仕事」と「データを変える仕事」を分けよう！

* **どんな問題を解決するの？**
    * 単にデータを画面に表示したいだけなのに、データを更新するための複雑な処理も一緒に考えないといけない。
    * データを読み込むときと書き込むときで、最適なやり方（パフォーマンスなど）が違うことがある。
* **考え方:**
    * データの「**問い合わせ (Query)**」（例: ユーザー一覧を表示する）と、「**命令 (Command)**」（例: ユーザーを新規登録する、情報を更新する）を、はっきりと別の処理経路・別のコードとして分ける。
    * **例:** 私たちのプロジェクトでは、`IUserQueryRepository` (データを読むための契約) と `IUserCommandRepository` (データを変えるための契約) のように、リポジトリのインターフェースと実装を分けています。
* **開発者にとってのメリット:**
    * **コードがシンプルになる:** 「データを読むだけ」「データを変えるだけ」と役割が限定されるので、それぞれのコードが単純になり、理解しやすくなります。
    * **意図が明確になる:** `QueryRepository` を使っていれば「ここはデータを読むだけだな」、`CommandRepository` なら「ここでデータが変わるんだな」と、コードの意図が明確になります。うっかりデータを書き換えてしまうようなミスも減らせます。
    * **(少し高度だけど) 最適化しやすくなる:** データを読むときは読み込みやすいように、データを書き込むときは安全・確実に書き込めるように、それぞれの処理に合わせた最適な実装を選びやすくなります。

---

### まとめ

DDD、クリーンアーキテクチャ、CQRS は、一見するとルールが多くて難しそうに見えるかもしれません。でも、これらは全て、ソフトウェア開発でよく起こる問題を解決し、**開発をもっと楽に、安全に、そしてチームで協力しやすくするための「賢い道具」**なんです。

この設計に従うことで、コードは整理され、変更に強くなり、ビジネスの本質を捉えやすくなります。最初は少し戸惑うかもしれませんが、慣れてくると、きっとそのメリットを実感できるはずですよ！
